{"version":3,"file":"HeightMapToNormalMap-8GtkSO_A.js","sources":["../../demo/scenarios/Shaders/HeightMapToNormalMap/glsl/vertex.glsl","../../demo/scenarios/Shaders/HeightMapToNormalMap/glsl/fragment.glsl","../../demo/scenarios/Shaders/HeightMapToNormalMap/HeightMapToNormalMap.tsx"],"sourcesContent":["\nvarying vec2 vUv;\n\nvoid main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n     vUv = uv;\n}\n","#include /node_modules/lygia/sample/normalFromHeightMap\n\n\nuniform sampler2D uHeightMap;\nuniform float uIntensity;\nuniform float uOffset;\n\nvarying vec2 vUv;\n\nvoid main() {\n    vec4 textureColor = texture2D(uHeightMap, vUv);\n    /*\n    normalFromHeightMap(\n      sampler2D heightMap,  // your height texture\n      vec2 st,              // UV coords\n      float strength,       // how strong is the normal effect\n      float offset          // small bias if needed\n    )\n    */\n    vec3 normal = normalFromHeightMap(uHeightMap, vUv, uIntensity, uOffset);\n    normal = normal * 0.5 + 0.5; // from [-1, 1] to [0, 1]\n    gl_FragColor = vec4(normal, 1.0);\n}\n","import * as THREE from 'three';\nimport { useEffect } from 'react';\nimport { useThree } from '@react-three/fiber';\n// @ts-ignore\nimport { CustomControl } from 'src/components/CustomControl/CustomControl';\nimport { usePlay } from 'src/lib/hooks';\nimport { useStats } from 'lib/hooks';\nimport { api } from 'src';\n\nimport vertexShader from './glsl/vertex.glsl';\nimport fragmentShader from './glsl/fragment.glsl';\n\nconst heightMap = (\n  await api.createTexturesFromImages('textures/pbr/castle_brick_02/castle_brick_02_red_4k_disp.jpg')\n)[0];\n\nconst planeGeometry = new THREE.PlaneGeometry(10, 10, 1, 1);\n\nconst material = new THREE.ShaderMaterial({\n  vertexShader,\n  fragmentShader,\n  wireframe: false,\n  side: THREE.DoubleSide,\n  transparent: false,\n  uniforms: {\n    uHeightMap: { value: heightMap },\n    uIntensity: { value: 2 },\n    uOffset: { value: 0.3 }\n  }\n});\n\nexport function HeightMapToNormalMap() {\n  const { scene, camera, gl } = useThree();\n  useStats();\n\n  useEffect(() => {\n    return api.registerDefaultPlayTriggers();\n  }, []);\n\n  useEffect(() => {\n    // because R3F adds geometry asynchronously, after internal setup\n    api.updateSceneBBox();\n    // Set up the scene\n    scene.background = new THREE.Color().setHex(0x000000);\n    return () => {\n      scene.background = null;\n    };\n  }, [scene]);\n\n  useEffect(() => {\n    camera.position.set(0, 0, 9);\n    camera.rotation.set(0, 0, 0);\n    if (camera instanceof THREE.OrthographicCamera) {\n      camera.zoom = 65;\n    }\n  }, [camera]);\n\n  usePlay((_playingState, _rootState, _delta) => {});\n\n  return (\n    <>\n      <mesh\n        position={[0, 0, 0]}\n        name=\"mesh\"\n        __inspectorData={{ isInspectable: true }}\n        geometry={planeGeometry}\n        material={material}\n      />\n\n      <CustomControl\n        name={'uIntensity'}\n        object={material.uniforms.uIntensity}\n        prop={'value'}\n        control={{\n          label: 'Intensity',\n          min: 0,\n          max: 10,\n          step: 0.1\n          // onChange: () => {}\n        }}\n      />\n      <CustomControl\n        name={'uOffset'}\n        object={material.uniforms.uOffset}\n        prop={'value'}\n        control={{\n          label: 'Offset',\n          min: -1,\n          max: 1,\n          step: 0.01\n          // onChange: () => {}\n        }}\n      />\n      <CustomControl\n        name={'uHeightMap'}\n        object={material.uniforms.uHeightMap}\n        prop={'value'}\n        control={{\n          label: 'Height Map',\n          gl,\n          color: { type: 'float' },\n          onChange: (...args: any[]) => {\n            console.log('Experience reacting to SceneBG value change', args);\n          }\n        }}\n      />\n    </>\n  );\n}\n\nexport default HeightMapToNormalMap;\n"],"names":["vertex_default","fragment_default","heightMap","api","planeGeometry","THREE.PlaneGeometry","material","THREE.ShaderMaterial","vertexShader","fragmentShader","THREE.DoubleSide","HeightMapToNormalMap","scene","camera","gl","useThree","useStats","useEffect","THREE.Color","THREE.OrthographicCamera","usePlay","_playingState","_rootState","_delta","jsxs","Fragment","jsx","CustomControl","args"],"mappings":"8QAAA,IAAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAAC,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCYA,MAAMC,GACJ,MAAMC,EAAI,yBAAyB,8DAA8D,GACjG,CAAC,EAEGC,EAAgB,IAAIC,EAAoB,GAAI,GAAI,EAAG,CAAC,EAEpDC,EAAW,IAAIC,EAAqB,CAAA,aACxCC,EAAA,eACAC,EACA,UAAW,GACX,KAAMC,EACN,YAAa,GACb,SAAU,CACR,WAAY,CAAE,MAAOR,CAAU,EAC/B,WAAY,CAAE,MAAO,CAAE,EACvB,QAAS,CAAE,MAAO,EAAI,CAAA,CAE1B,CAAC,EAEM,SAASS,GAAuB,CACrC,KAAM,CAAE,MAAAC,EAAO,OAAAC,EAAQ,GAAAC,CAAA,EAAOC,EAAS,EAC9B,OAAAC,EAAA,EAETC,EAAAA,UAAU,IACDd,EAAI,4BAA4B,EACtC,EAAE,EAELc,EAAAA,UAAU,KAERd,EAAI,gBAAgB,EAEpBS,EAAM,WAAa,IAAIM,EAAY,EAAE,OAAO,CAAQ,EAC7C,IAAM,CACXN,EAAM,WAAa,IACrB,GACC,CAACA,CAAK,CAAC,EAEVK,EAAAA,UAAU,IAAM,CACdJ,EAAO,SAAS,IAAI,EAAG,EAAG,CAAC,EAC3BA,EAAO,SAAS,IAAI,EAAG,EAAG,CAAC,EACvBA,aAAkBM,IACpBN,EAAO,KAAO,GAChB,EACC,CAACA,CAAM,CAAC,EAEHO,EAAA,CAACC,EAAeC,EAAYC,IAAW,CAAA,CAAE,EAI7CC,EAAA,KAAAC,WAAA,CAAA,SAAA,CAAAC,EAAA,IAAC,OAAA,CACC,SAAU,CAAC,EAAG,EAAG,CAAC,EAClB,KAAK,OACL,gBAAiB,CAAE,cAAe,EAAK,EACvC,SAAUtB,EACV,SAAAE,CAAA,CACF,EAEAoB,EAAA,IAACC,EAAA,CACC,KAAM,aACN,OAAQrB,EAAS,SAAS,WAC1B,KAAM,QACN,QAAS,CACP,MAAO,YACP,IAAK,EACL,IAAK,GACL,KAAM,EAAA,CAER,CACF,EACAoB,EAAA,IAACC,EAAA,CACC,KAAM,UACN,OAAQrB,EAAS,SAAS,QAC1B,KAAM,QACN,QAAS,CACP,MAAO,SACP,IAAK,GACL,IAAK,EACL,KAAM,GAAA,CAER,CACF,EACAoB,EAAA,IAACC,EAAA,CACC,KAAM,aACN,OAAQrB,EAAS,SAAS,WAC1B,KAAM,QACN,QAAS,CACP,MAAO,aACP,GAAAQ,EACA,MAAO,CAAE,KAAM,OAAQ,EACvB,SAAU,IAAIc,IAAgB,CACpB,QAAA,IAAI,8CAA+CA,CAAI,CAAA,CACjE,CACF,CAAA,CACF,EACF,CAEJ"}