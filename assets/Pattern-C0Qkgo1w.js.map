{"version":3,"file":"Pattern-C0Qkgo1w.js","sources":["../../demo/scenarios/Shaders/Pattern/glsl/vertex.glsl","../../demo/scenarios/Shaders/Pattern/glsl/fragment.glsl","../../demo/scenarios/Shaders/Pattern/Pattern.tsx"],"sourcesContent":["\nvarying vec2 vUv;\n\nvoid main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n     vUv = uv;\n}\n","#include /src/glsl/math\n#include /src/glsl/uv\n#include /src/glsl/patterns\nvarying vec2 vUv;\n\nuniform int uPattern;\n\n\n\nvoid main() {\n    if (uPattern == 1) {\n        gl_FragColor = vec4(vec3(mod(vUv.y * 10.0, 1.0)), 1.0);\n    } else if (uPattern == 2) {\n        gl_FragColor = vec4(vec3(step(0.5, mod(vUv.y * 10.0, 1.0))), 1.0);\n    }  else if (uPattern == 3) {\n        gl_FragColor = vec4(vec3(step(0.9, mod((vUv.y) * 10.0, 1.0))) + vec3(step(0.9, mod((vUv.x) * 10.0, 1.0))), 1.0);\n    } else if (uPattern == 4) {\n        gl_FragColor = vec4(vec3(step(0.9, mod((vUv.y) * 10.0, 1.0))) * vec3(step(0.9, mod((vUv.x) * 10.0, 1.0))), 1.0);\n    } else if (uPattern == 5) {\n        vec3 barX = vec3(step(0.9, mod((vUv.y) * 10.0, 1.0))) * vec3(step(0.4, mod((vUv.x) * 10.0, 1.0)));\n        vec3 barY = vec3(step(0.9, mod((vUv.x) * 10.0, 1.0))) * vec3(step(0.4, mod((vUv.y) * 10.0, 1.0)));\n        gl_FragColor = vec4(barX + barY, 1.0);\n    } else if (uPattern == 6) {\n        vec3 barX = vec3(step(0.8, mod((vUv.y) * 10.0, 1.0))) * vec3(step(0.4, mod((vUv.x-0.02) * 10.0, 1.0)));\n        vec3 barY = vec3(step(0.8, mod((vUv.x) * 10.0, 1.0))) * vec3(step(0.4, mod((vUv.y-0.02) * 10.0, 1.0)));\n        gl_FragColor = vec4(barX + barY, 1.0);\n    } else if (uPattern == 7) {\n        gl_FragColor = vec4(abs(0.5 - vec3(vUv.x)) * 2.0 ,1.0);\n    } else if (uPattern == 8) {\n        gl_FragColor = vec4(min(abs(0.5 - vec3(vUv.x)), abs(0.5 - vec3(vUv.y))), 1.0);\n    } else if (uPattern == 9) {\n        gl_FragColor = vec4(max(abs(0.5 - vec3(vUv.x)), abs(0.5 - vec3(vUv.y))), 1.0);\n    } else if (uPattern == 10) {\n        gl_FragColor = vec4(step(0.25, max(abs(0.5 - vec3(vUv.x)), abs(0.5 - vec3(vUv.y)))), 1.0);\n    } else if (uPattern == 11) {\n        vec3 square_1 = vec3(step(0.25, max(abs(0.5 - vec3(vUv.x)), abs(0.5 - vec3(vUv.y)))));\n        vec3 square_2 = 1.0 - vec3(step(0.30, max(abs(0.5 - vec3(vUv.x)), abs(0.5 - vec3(vUv.y)))));\n        gl_FragColor = vec4(square_1 * square_2, 1.0);\n    } else if (uPattern == 12) {\n        gl_FragColor = vec4(vec3(floor(vUv.y * 10.0) / 10.0), 1.0);\n    } else if (uPattern == 13) {\n        gl_FragColor = vec4(vec3(floor(vUv.y * 10.0) / 10.0 * floor(vUv.x * 10.0) / 10.0), 1.0);\n    } else if (uPattern == 14) {\n        gl_FragColor = vec4(vec3(_random(vUv.xy)), 1.0);\n    } else if (uPattern == 15) {\n        vec2 st = vUv.xy * 10.0;\n        vec2 ipos = floor(st); // integer part\n        vec2 fpos = fract(st); // fraction part\n        float rnd = _random(ipos);\n\n        float col = 3.0;\n        float row = 2.0;\n        float cellMatch1 = selectGridCell(ipos, 2.0, 3.0);\n        float cellMatch2 = selectGridCell(ipos, 2.0, 4.0);\n\n        // Soft circle inside the every cell\n        float d = distance(fpos, vec2(0.5));\n        float shapeAlphaMask = smoothstep(0.3, 0.29, d);\n\n        vec3 bgColor = vec3(rnd);\n        vec3 cellColor = vec3(0.2, 1.0, 0.2);\n\n        float mask = shapeAlphaMask * cellMatch1 + shapeAlphaMask * cellMatch2;\n\n\n        gl_FragColor = vec4(mix(bgColor, cellColor, mask), 1.0);\n\n    } else if (uPattern == 16) {\n        vec2 st = vUv.xy * 10.0;\n//        st = st - vec2(5.0); // translate 0,0 be the center\n//        st *= 5.0; // scale (zoom out)\n        vec2 ipos = floor(st); // integer part\n        vec2 fpos = fract(st); // fraction part\n        float rnd = _random(ipos);\n\n        float color = 0.0;\n//        vec2 tile = fpos;\n        vec2 tile = truchetPattern(fpos, rnd);\n//        color = fpos.y;\n        // Maze\n        color = smoothstep(tile.x - 0.3, tile.x, tile.y) -\n                smoothstep(tile.x, tile.x + 0.3, tile.y);\n\n        // Circles\n//        color = (step(length(tile), 0.6) - step(length(tile), 0.4)) +\n//                (step(length(tile - vec2(1.)), 0.6) - step(length(tile - vec2(1.)), 0.4));\n\n        // Truchet (2 triangles)\n//        color = step(tile.x, tile.y);\n\n        gl_FragColor = vec4(vec3(color), 1.0);\n\n    } else {\n        gl_FragColor = vec4(vec2(1.0 - vUv.y, vUv.x), 0.0, 1.0);\n    }\n\n}\n","import * as THREE from 'three';\nimport { useEffect, useRef } from 'react';\nimport { useThree } from '@react-three/fiber';\n// @ts-ignore\nimport { CustomControl } from 'src/components/CustomControl/CustomControl';\nimport { usePlay } from 'src/lib/hooks';\nimport { useStats } from 'lib/hooks';\nimport { api } from 'src';\n\nimport vertexShader from './glsl/vertex.glsl';\nimport fragmentShader from './glsl/fragment.glsl';\n\nconst planeGeometry = new THREE.PlaneGeometry(10, 10, 1, 1);\n\nconst material = new THREE.ShaderMaterial({\n  vertexShader,\n  fragmentShader,\n  wireframe: false,\n  side: THREE.DoubleSide,\n  transparent: false,\n  uniforms: {\n    uPattern: { value: 1 }\n  }\n});\n\nexport function Pattern() {\n  const { scene, camera } = useThree();\n  useStats();\n\n  const paramsRef = useRef({\n    tessellation: planeGeometry.parameters.heightSegments\n  });\n\n  useEffect(() => {\n    return api.registerDefaultPlayTriggers();\n  }, []);\n\n  useEffect(() => {\n    // because R3F adds geometry asynchronously, after internal setup\n    api.updateSceneBBox();\n    // Set up the scene\n    scene.background = new THREE.Color().setHex(0x000000);\n    return () => {\n      scene.background = null;\n    };\n  }, [scene]);\n\n  useEffect(() => {\n    camera.position.set(0, 0, 9);\n    camera.rotation.set(0, 0, 0);\n    if (camera instanceof THREE.OrthographicCamera) {\n      camera.zoom = 65;\n    }\n  }, [camera]);\n\n  usePlay((_playingState, _rootState, _delta) => {});\n\n  return (\n    <>\n      <mesh\n        position={[0, 0, 0]}\n        name=\"mesh\"\n        __inspectorData={{ isInspectable: true }}\n        geometry={planeGeometry}\n        material={material}\n      />\n      <CustomControl\n        name={'tessellation'}\n        object={paramsRef.current}\n        prop={'tessellation'}\n        control={{\n          label: 'Tessellation',\n          min: 1,\n          max: 256,\n          step: 1,\n          onChange: (value) => {\n            planeGeometry.dispose();\n            const newGeometry = new THREE.PlaneGeometry(10, 10, value, value);\n            planeGeometry.copy(newGeometry);\n          }\n        }}\n      />\n      <CustomControl\n        name={'pattern'}\n        object={material.uniforms.uPattern}\n        prop={'value'}\n        control={{\n          label: 'Pattern',\n          min: 1,\n          max: 20,\n          step: 1\n        }}\n      />\n    </>\n  );\n}\n\nexport default Pattern;\n"],"names":["vertex_default","fragment_default","planeGeometry","THREE.PlaneGeometry","material","THREE.ShaderMaterial","vertexShader","fragmentShader","THREE.DoubleSide","Pattern","scene","camera","useThree","useStats","paramsRef","useRef","useEffect","api","THREE.Color","THREE.OrthographicCamera","usePlay","_playingState","_rootState","_delta","jsxs","Fragment","jsx","CustomControl","value","newGeometry"],"mappings":"mRAAA,IAAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAAC,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCYA,MAAMC,EAAgB,IAAIC,EAAoB,GAAI,GAAI,EAAG,CAAC,EAEpDC,EAAW,IAAIC,EAAqB,CAAA,aACxCC,EAAA,eACAC,EACA,UAAW,GACX,KAAMC,EACN,YAAa,GACb,SAAU,CACR,SAAU,CAAE,MAAO,CAAE,CAAA,CAEzB,CAAC,EAEM,SAASC,GAAU,CACxB,KAAM,CAAE,MAAAC,EAAO,OAAAC,CAAO,EAAIC,EAAS,EAC1BC,EAAA,EAET,MAAMC,EAAYC,EAAAA,OAAO,CACvB,aAAcb,EAAc,WAAW,cAAA,CACxC,EAEDc,OAAAA,EAAAA,UAAU,IACDC,EAAI,4BAA4B,EACtC,EAAE,EAELD,EAAAA,UAAU,KAERC,EAAI,gBAAgB,EAEpBP,EAAM,WAAa,IAAIQ,EAAY,EAAE,OAAO,CAAQ,EAC7C,IAAM,CACXR,EAAM,WAAa,IACrB,GACC,CAACA,CAAK,CAAC,EAEVM,EAAAA,UAAU,IAAM,CACdL,EAAO,SAAS,IAAI,EAAG,EAAG,CAAC,EAC3BA,EAAO,SAAS,IAAI,EAAG,EAAG,CAAC,EACvBA,aAAkBQ,IACpBR,EAAO,KAAO,GAChB,EACC,CAACA,CAAM,CAAC,EAEHS,EAAA,CAACC,EAAeC,EAAYC,IAAW,CAAA,CAAE,EAI7CC,EAAA,KAAAC,WAAA,CAAA,SAAA,CAAAC,EAAA,IAAC,OAAA,CACC,SAAU,CAAC,EAAG,EAAG,CAAC,EAClB,KAAK,OACL,gBAAiB,CAAE,cAAe,EAAK,EACvC,SAAUxB,EACV,SAAAE,CAAA,CACF,EACAsB,EAAA,IAACC,EAAA,CACC,KAAM,eACN,OAAQb,EAAU,QAClB,KAAM,eACN,QAAS,CACP,MAAO,eACP,IAAK,EACL,IAAK,IACL,KAAM,EACN,SAAWc,GAAU,CACnB1B,EAAc,QAAQ,EACtB,MAAM2B,EAAc,IAAI1B,EAAoB,GAAI,GAAIyB,EAAOA,CAAK,EAChE1B,EAAc,KAAK2B,CAAW,CAAA,CAChC,CACF,CACF,EACAH,EAAA,IAACC,EAAA,CACC,KAAM,UACN,OAAQvB,EAAS,SAAS,SAC1B,KAAM,QACN,QAAS,CACP,MAAO,UACP,IAAK,EACL,IAAK,GACL,KAAM,CAAA,CACR,CAAA,CACF,EACF,CAEJ"}