{"version":3,"file":"Pattern-D9FX5B77.js","sources":["../../demo/scenarios/Shaders/Pattern/glsl/vertex.glsl","../../demo/scenarios/Shaders/Pattern/glsl/fragment.glsl","../../demo/scenarios/Shaders/Pattern/Pattern.tsx"],"sourcesContent":["\nvarying vec2 vUv;\n\nvoid main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n     vUv = uv;\n}\n","#include /src/glsl/math\n#include /src/glsl/uv\n#include /src/glsl/patterns\n#include /src/glsl/perlinNoise\nvarying vec2 vUv;\n\nuniform int uPattern;\nuniform vec4 uVars;\n\n\nvoid main() {\n    if (uPattern == 1) {\n        vec2 st = vec2(vUv.x, vUv.y + vUv.x * uVars.x * 2.0);\n        float steps = 10.0 + floor(uVars.y * 10.0);\n        gl_FragColor = vec4(vec3(mod(st.y * steps, 1.0)), 1.0);\n    } else if (uPattern == 2) {\n        gl_FragColor = vec4(vec3(step(0.5, mod(vUv.y * 10.0, 1.0))), 1.0);\n    }  else if (uPattern == 3) {\n        gl_FragColor = vec4(vec3(step(0.9, mod((vUv.y) * 10.0, 1.0))) + vec3(step(0.9, mod((vUv.x) * 10.0, 1.0))), 1.0);\n    } else if (uPattern == 4) {\n        gl_FragColor = vec4(vec3(step(0.9, mod((vUv.y) * 10.0, 1.0))) * vec3(step(0.9, mod((vUv.x) * 10.0, 1.0))), 1.0);\n    } else if (uPattern == 5) {\n        vec3 barX = vec3(step(0.9, mod((vUv.y) * 10.0, 1.0))) * vec3(step(0.4, mod((vUv.x) * 10.0, 1.0)));\n        vec3 barY = vec3(step(0.9, mod((vUv.x) * 10.0, 1.0))) * vec3(step(0.4, mod((vUv.y) * 10.0, 1.0)));\n        gl_FragColor = vec4(barX + barY, 1.0);\n    } else if (uPattern == 6) {\n        float offsetStrength = uVars.x == 0.0 ? 1.0 : uVars.x * 2.0;\n        float barX = step(0.4, mod(vUv.x * 10.0 - 0.2 * offsetStrength, 1.0)) * step(0.8, mod(vUv.y * 10.0, 1.0));\n        float barY = step(0.8, mod(vUv.x * 10.0, 1.0)) * step(0.4, mod(vUv.y * 10.0 - 0.2 * offsetStrength, 1.0));\n        float strength = barX + barY;\n        gl_FragColor = vec4(vec3(strength), 1.0);\n    } else if (uPattern == 7) {\n        gl_FragColor = vec4(abs(0.5 - vec3(vUv.x)) * 2.0 ,1.0);\n    } else if (uPattern == 8) {\n        gl_FragColor = vec4(min(abs(0.5 - vec3(vUv.x)), abs(0.5 - vec3(vUv.y))), 1.0);\n    } else if (uPattern == 9) {\n        gl_FragColor = vec4(max(abs(0.5 - vec3(vUv.x)), abs(0.5 - vec3(vUv.y))), 1.0);\n    } else if (uPattern == 10) {\n        gl_FragColor = vec4(step(0.25, max(abs(0.5 - vec3(vUv.x)), abs(0.5 - vec3(vUv.y)))), 1.0);\n    } else if (uPattern == 11) {\n        vec3 square_1 = vec3(step(0.25, max(abs(0.5 - vec3(vUv.x)), abs(0.5 - vec3(vUv.y)))));\n        vec3 square_2 = 1.0 - vec3(step(0.30, max(abs(0.5 - vec3(vUv.x)), abs(0.5 - vec3(vUv.y)))));\n        gl_FragColor = vec4(square_1 * square_2, 1.0);\n    } else if (uPattern == 12) {\n        gl_FragColor = vec4(vec3(floor(vUv.y * 10.0) / 10.0), 1.0);\n    } else if (uPattern == 13) {\n        gl_FragColor = vec4(vec3(floor(vUv.y * 10.0) / 10.0 * floor(vUv.x * 10.0) / 10.0), 1.0);\n    } else if (uPattern == 14) {\n        gl_FragColor = vec4(vec3(_random(vUv.xy)), 1.0);\n    } else if (uPattern == 15) {\n        vec2 st = vUv.xy * 10.0;\n//        vec2 st = vec2((vUv.x + vUv.y/50.0) * 10.0, vUv.y * 10.0);\n        vec2 ipos = floor(st); // integer part\n        vec2 fpos = fract(st); // fraction part\n        float rnd = _random(ipos);\n\n        float col = 3.0;\n        float row = 2.0;\n        float cellMatch1 = selectGridCell(ipos, floor(uVars.x * 10.0), floor(uVars.x * 10.0));\n        float cellMatch2 = selectGridCell(ipos, floor(uVars.y * 10.0), floor(uVars.y * 10.0));\n\n        // Soft circle inside the every cell\n        float d = distance(fpos, vec2(0.5));\n        float shapeAlphaMask = smoothstep(0.3, 0.29, d);\n\n        vec3 bgColor = vec3(rnd);\n        vec3 cellColor = vec3(0.2, 1.0, 0.2);\n\n        float mask = shapeAlphaMask * cellMatch1 + shapeAlphaMask * cellMatch2;\n\n\n        gl_FragColor = vec4(mix(bgColor, cellColor, mask), 1.0);\n\n    } else if (uPattern == 16) {\n        vec2 st = vUv.xy * 10.0;\n//        st = st - vec2(5.0); // translate 0,0 be the center\n//        st *= 5.0; // scale (zoom out)\n        vec2 ipos = floor(st); // integer part\n        vec2 fpos = fract(st); // fraction part\n        float rnd = _random(ipos);\n\n        float color = 0.0;\n//        vec2 tile = fpos;\n        vec2 tile = truchetPattern(fpos, rnd);\n//        color = fpos.y;\n        if (floor(uVars.x * 10.0) == 0.0) {\n            // Maze\n            color = smoothstep(tile.x - 0.3, tile.x, tile.y) -\n            smoothstep(tile.x, tile.x + 0.3, tile.y);\n        } else if (floor(uVars.x * 10.0) == 1.0) {\n            // Circles\n            color = (step(length(tile), 0.6) - step(length(tile), 0.4)) +\n                    (step(length(tile - vec2(1.)), 0.6) - step(length(tile - vec2(1.)), 0.4));\n        } else {\n            // Truchet (2 triangles)\n            color = step(tile.x, tile.y);\n        }\n\n        gl_FragColor = vec4(vec3(color), 1.0);\n\n    } else if (uPattern == 17) {\n        gl_FragColor = vec4(1.0 - vec3(distance(vUv, vec2(uVars.x, uVars.y))), 1.0);\n    } else if (uPattern == 18) {\n        gl_FragColor = vec4(0.01 / vec3(distance(vUv, vec2(uVars.x, uVars.y))), 1.0);\n    } else if (uPattern == 19) {\n        vec2 vUvRot = _rotate2D(vUv, PI/180.0*360.0*uVars.x, vec2(0.5));\n        float stretch = uVars.y == 0.0 ? 0.2 : (1.0 - uVars.y);\n        float lightX = 0.01 / distance(vec2(vUvRot.x * stretch, vUvRot.y), vec2(0.5 * stretch, 0.5));\n        float lightY = 0.01 / distance(vec2(vUvRot.x , vUvRot.y * stretch), vec2(0.5, 0.5 * stretch));\n        gl_FragColor = vec4(vec3(lightX * lightY), 1.0);\n    } else if (uPattern == 20) {\n        vec2 wavedUv = vec2(\n            vUv.x + sin(vUv.y * 30.0) * uVars.z,\n            vUv.y + sin(vUv.x * 30.0) * uVars.z\n        );\n        float d = abs(distance(wavedUv, vec2(0.5)) - uVars.x);\n        if (uVars.y * 10.0 > 1.0) {\n            d = step(0.01, d);\n        }\n        gl_FragColor = vec4(vec3(d), 1.0);\n    } else if (uPattern == 21) {\n        float angle = atan(vUv.y - uVars.y, vUv.x - uVars.x) / (PI * 2.0) + 0.5;\n        float angles = mod(angle * (uVars.z * 10.0 + 1.0), 1.0);\n        gl_FragColor = vec4(vec3(angles), 1.0);\n    } else if (uPattern == 22) {\n        float angle = atan(vUv.y - 0.5, vUv.x - 0.5) / (PI * 2.0) + 0.5;\n        float wave = sin(angle * (1.0 + uVars.x * 50.0));\n        gl_FragColor = vec4(vec3(wave), 1.0);\n    } else if (uPattern == 23) {\n        float angle = atan(vUv.y - 0.5, vUv.x - 0.5) / (PI * 2.0) + 0.5;\n        float sinusoid = sin(angle * (1.0 + uVars.y * 100.0));\n        float radius = 0.25;\n\n        if (floor(uVars.x * 10.0) < 1.0) {\n            radius *= sinusoid;\n        } else {\n            radius += sinusoid / 50.0;\n        }\n\n        float d = abs(distance(vUv, vec2(0.5)) - radius);\n        float circle = 1.0 - step(0.01, d);\n\n        gl_FragColor = vec4(vec3(circle), 1.0);\n    } else if (uPattern == 24) {\n        float pNoise = cnoise(vUv * (1.0 + uVars.x * 100.0));\n        gl_FragColor = vec4(vec3(pNoise), 1.0);\n    } else if (uPattern == 25) {\n        float pNoise = step(0.1, cnoise(vUv * (1.0 + uVars.x * 100.0)));\n        gl_FragColor = vec4(vec3(pNoise), 1.0);\n    } else if (uPattern == 26) {\n        float pNoise = sin(cnoise(vUv * (1.0 + uVars.x * 100.0)) * 20.0);\n        gl_FragColor = vec4(vec3(pNoise), 1.0);\n    } else {\n        gl_FragColor = vec4(vec2(1.0 - vUv.y, vUv.x), 0.0, 1.0);\n    }\n\n}\n","import * as THREE from 'three';\nimport { useEffect } from 'react';\nimport { useThree } from '@react-three/fiber';\n// @ts-ignore\nimport { CustomControl } from 'src/components/CustomControl/CustomControl';\nimport { usePlay } from 'src/lib/hooks';\nimport { useStats } from 'lib/hooks';\nimport { api } from 'src';\n\nimport vertexShader from './glsl/vertex.glsl';\nimport fragmentShader from './glsl/fragment.glsl';\n\nconst planeGeometry = new THREE.PlaneGeometry(10, 10, 1, 1);\n\nconst material = new THREE.ShaderMaterial({\n  vertexShader,\n  fragmentShader,\n  wireframe: false,\n  side: THREE.DoubleSide,\n  transparent: false,\n  uniforms: {\n    uPattern: { value: 1 },\n    uVars: { value: new THREE.Vector4(0, 0, 0, 0) }\n  }\n});\n\nexport function Pattern() {\n  const { scene, camera } = useThree();\n  useStats();\n\n  // const paramsRef = useRef({});\n\n  useEffect(() => {\n    return api.registerDefaultPlayTriggers();\n  }, []);\n\n  useEffect(() => {\n    // because R3F adds geometry asynchronously, after internal setup\n    api.updateSceneBBox();\n    // Set up the scene\n    scene.background = new THREE.Color().setHex(0x000000);\n    return () => {\n      scene.background = null;\n    };\n  }, [scene]);\n\n  useEffect(() => {\n    camera.position.set(0, 0, 9);\n    camera.rotation.set(0, 0, 0);\n    if (camera instanceof THREE.OrthographicCamera) {\n      camera.zoom = 65;\n    }\n  }, [camera]);\n\n  usePlay((_playingState, _rootState, _delta) => {});\n\n  return (\n    <>\n      <mesh\n        position={[0, 0, 0]}\n        name=\"mesh\"\n        __inspectorData={{ isInspectable: true }}\n        geometry={planeGeometry}\n        material={material}\n      />\n      <CustomControl\n        name={'pattern'}\n        object={material.uniforms.uPattern}\n        prop={'value'}\n        control={{\n          label: 'Pattern',\n          min: 1,\n          max: 30,\n          step: 1\n        }}\n      />\n      <CustomControl\n        name={'vars'}\n        object={material.uniforms.uVars}\n        prop={'value'}\n        control={{\n          label: 'Vars',\n          x: { min: 0, max: 1, step: 0.01, pointerScale: 0.01 },\n          y: { min: 0, max: 1, step: 0.01, pointerScale: 0.01 },\n          z: { min: 0, max: 1, step: 0.01, pointerScale: 0.01 },\n          w: { min: 0, max: 1, step: 0.01, pointerScale: 0.01 }\n        }}\n      />\n    </>\n  );\n}\n\nexport default Pattern;\n"],"names":["vertex_default","fragment_default","planeGeometry","THREE.PlaneGeometry","material","THREE.ShaderMaterial","vertexShader","fragmentShader","THREE.DoubleSide","THREE.Vector4","Pattern","scene","camera","useThree","useStats","useEffect","api","THREE.Color","THREE.OrthographicCamera","usePlay","_playingState","_rootState","_delta","jsxs","Fragment","jsx","CustomControl"],"mappings":"sRAAA,IAAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAAC,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCYA,MAAMC,EAAgB,IAAIC,EAAoB,GAAI,GAAI,EAAG,CAAC,EAEpDC,EAAW,IAAIC,EAAqB,CAAA,aACxCC,EAAA,eACAC,EACA,UAAW,GACX,KAAMC,EACN,YAAa,GACb,SAAU,CACR,SAAU,CAAE,MAAO,CAAE,EACrB,MAAO,CAAE,MAAO,IAAIC,EAAc,EAAG,EAAG,EAAG,CAAC,CAAE,CAAA,CAElD,CAAC,EAEM,SAASC,GAAU,CACxB,KAAM,CAAE,MAAAC,EAAO,OAAAC,CAAO,EAAIC,EAAS,EAC1B,OAAAC,EAAA,EAITC,EAAAA,UAAU,IACDC,EAAI,4BAA4B,EACtC,EAAE,EAELD,EAAAA,UAAU,KAERC,EAAI,gBAAgB,EAEpBL,EAAM,WAAa,IAAIM,EAAY,EAAE,OAAO,CAAQ,EAC7C,IAAM,CACXN,EAAM,WAAa,IACrB,GACC,CAACA,CAAK,CAAC,EAEVI,EAAAA,UAAU,IAAM,CACdH,EAAO,SAAS,IAAI,EAAG,EAAG,CAAC,EAC3BA,EAAO,SAAS,IAAI,EAAG,EAAG,CAAC,EACvBA,aAAkBM,IACpBN,EAAO,KAAO,GAChB,EACC,CAACA,CAAM,CAAC,EAEHO,EAAA,CAACC,EAAeC,EAAYC,IAAW,CAAA,CAAE,EAI7CC,EAAA,KAAAC,WAAA,CAAA,SAAA,CAAAC,EAAA,IAAC,OAAA,CACC,SAAU,CAAC,EAAG,EAAG,CAAC,EAClB,KAAK,OACL,gBAAiB,CAAE,cAAe,EAAK,EACvC,SAAUvB,EACV,SAAAE,CAAA,CACF,EACAqB,EAAA,IAACC,EAAA,CACC,KAAM,UACN,OAAQtB,EAAS,SAAS,SAC1B,KAAM,QACN,QAAS,CACP,MAAO,UACP,IAAK,EACL,IAAK,GACL,KAAM,CAAA,CACR,CACF,EACAqB,EAAA,IAACC,EAAA,CACC,KAAM,OACN,OAAQtB,EAAS,SAAS,MAC1B,KAAM,QACN,QAAS,CACP,MAAO,OACP,EAAG,CAAE,IAAK,EAAG,IAAK,EAAG,KAAM,IAAM,aAAc,GAAK,EACpD,EAAG,CAAE,IAAK,EAAG,IAAK,EAAG,KAAM,IAAM,aAAc,GAAK,EACpD,EAAG,CAAE,IAAK,EAAG,IAAK,EAAG,KAAM,IAAM,aAAc,GAAK,EACpD,EAAG,CAAE,IAAK,EAAG,IAAK,EAAG,KAAM,IAAM,aAAc,GAAK,CAAA,CACtD,CAAA,CACF,EACF,CAEJ"}